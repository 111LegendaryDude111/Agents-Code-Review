name: AI Review Check

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: ai-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  ai-review:
    if: ${{ !github.event.pull_request.draft }}
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      GITHUB_TOKEN: ${{ github.token }}
      GITHUB_REPOSITORY: ${{ github.repository }}
      PR_NUMBER: ${{ github.event.pull_request.number }}
      LLM_PROVIDER: huggingface
      LLM_MODEL: Qwen/Qwen2.5-Coder-32B-Instruct
      LLM_BASE_URL: https://router.huggingface.co/v1
      HF_TOKEN: ${{ secrets.HF_TOKEN }}
      AI_REVIEW_MAX_ISSUE_COMMENTS: "3"
      AI_REVIEW_MAX_SUMMARY_ITEMS: "20"
      AI_REVIEW_MAX_MESSAGE_CHARS: "220"
      AI_REVIEW_MAX_SUGGESTION_CHARS: "160"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Validate required secrets
        run: |
          if [ -z "${HF_TOKEN}" ]; then
            echo "Missing secret: HF_TOKEN"
            exit 1
          fi

      - name: Install dependencies
        run: make setup

      - name: Run AI review
        run: make run

      - name: Publish AI review comments to PR
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const fs = require("fs");
            const crypto = require("crypto");

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.issue.number;

            if (!issue_number) {
              core.warning("No pull request context. Skipping comment publish.");
              return;
            }

            if (!fs.existsSync("result.json")) {
              core.warning("result.json not found. Skipping comment publish.");
              return;
            }

            let result;
            try {
              result = JSON.parse(fs.readFileSync("result.json", "utf8"));
            } catch (error) {
              core.warning(`Failed to parse result.json: ${error.message}`);
              return;
            }

            const issues = Array.isArray(result.issues) ? result.issues : [];
            const summary = String(result.summary || "").trim();
            const decision = String(result.decision || "WARN").toUpperCase();
            const stats = result.stats && typeof result.stats === "object" ? result.stats : {};
            const riskScore = stats.risk_score ?? "n/a";

            const summaryMarker = "<!-- ai-review:summary -->";
            const issueMarkerPrefix = "<!-- ai-review:item:";
            const keysMarkerPrefix = "<!-- ai-review:keys:";

            const toPositiveInt = (raw, fallback) => {
              const n = Number.parseInt(raw, 10);
              return Number.isFinite(n) && n >= 0 ? n : fallback;
            };

            const limits = {
              maxIssueComments: toPositiveInt(process.env.AI_REVIEW_MAX_ISSUE_COMMENTS, 3),
              maxSummaryItems: toPositiveInt(process.env.AI_REVIEW_MAX_SUMMARY_ITEMS, 20),
              maxMessageChars: toPositiveInt(process.env.AI_REVIEW_MAX_MESSAGE_CHARS, 220),
              maxSuggestionChars: toPositiveInt(process.env.AI_REVIEW_MAX_SUGGESTION_CHARS, 160),
            };

            const severityOrder = {
              BLOCKER: 0,
              IMPORTANT: 1,
              CRITICAL: 2,
              HIGH: 3,
              MEDIUM: 4,
              LOW: 5,
              WARNING: 6,
              QUESTION: 7,
              NIT: 8,
            };

            const criticalSet = new Set(["BLOCKER", "IMPORTANT", "CRITICAL", "HIGH"]);

            const normalizeSeverity = (value) => {
              const severity = String(value || "NIT").trim().toUpperCase();
              return severity || "NIT";
            };

            const confidenceValue = (issue) =>
              typeof issue.confidence === "number" && Number.isFinite(issue.confidence)
                ? issue.confidence
                : -1;

            const confidenceText = (issue) =>
              confidenceValue(issue) >= 0 ? confidenceValue(issue).toFixed(2) : "n/a";

            const truncate = (value, maxChars) => {
              const text = String(value || "").replace(/\s+/g, " ").trim();
              if (!text) {
                return "";
              }
              if (text.length <= maxChars) {
                return text;
              }
              const head = Math.max(0, maxChars - 3);
              return `${text.slice(0, head).trimEnd()}...`;
            };

            const issueLocation = (issue) => {
              const path = issue.path || "unknown";
              const lineStart = issue.line_start ?? "?";
              const lineEnd = issue.line_end ?? lineStart;
              return `${path}:${lineStart}-${lineEnd}`;
            };

            const toIssueKey = (issue) => {
              const source = issue.fingerprint
                ? `fingerprint:${issue.fingerprint}`
                : issue.id != null && issue.id !== ""
                  ? `id:${issue.id}:${issue.path || "unknown"}:${issue.line_start || "?"}`
                  : `loc:${issue.path || "unknown"}:${issue.line_start || "?"}:${issue.title || "Issue"}`;
              return crypto.createHash("sha1").update(String(source)).digest("hex").slice(0, 16);
            };

            const compareEntries = (a, b) => {
              const rankA = severityOrder[a.severity] ?? 99;
              const rankB = severityOrder[b.severity] ?? 99;
              if (rankA !== rankB) {
                return rankA - rankB;
              }
              const confidenceDelta = confidenceValue(b.issue) - confidenceValue(a.issue);
              if (confidenceDelta !== 0) {
                return confidenceDelta;
              }
              const pathA = String(a.issue.path || "");
              const pathB = String(b.issue.path || "");
              if (pathA !== pathB) {
                return pathA.localeCompare(pathB);
              }
              return (a.issue.line_start ?? 0) - (b.issue.line_start ?? 0);
            };

            const formatIssueLine = (entry, includeSuggestion = false) => {
              const issue = entry.issue;
              const title = issue.title || "Issue";
              const location = issueLocation(issue);
              const message = truncate(issue.message, limits.maxMessageChars);
              const suggestion = truncate(issue.suggestion, limits.maxSuggestionChars);

              let line = `- [${entry.severity}] ${title} (\`${location}\`)`;
              if (message) {
                line += `: ${message}`;
              }
              if (includeSuggestion && suggestion) {
                line += ` | fix: ${suggestion}`;
              }
              return line;
            };

            const parseKeysMarker = (body) => {
              const text = String(body || "");
              const match = text.match(/<!-- ai-review:keys:([a-f0-9,]*) -->/);
              if (!match || !match[1]) {
                return new Set();
              }
              return new Set(match[1].split(",").filter(Boolean));
            };

            const uniqueByKey = new Map();
            for (const issue of issues) {
              const key = toIssueKey(issue);
              if (!uniqueByKey.has(key)) {
                uniqueByKey.set(key, issue);
              }
            }

            const issueEntries = Array.from(uniqueByKey.entries())
              .map(([key, issue]) => ({
                key,
                issue,
                severity: normalizeSeverity(issue.severity),
              }))
              .sort(compareEntries);

            const existingComments = await github.paginate(
              github.rest.issues.listComments,
              {
                owner,
                repo,
                issue_number,
                per_page: 100,
              }
            );

            const existingSummary = existingComments.find((c) =>
              (c.body || "").includes(summaryMarker)
            );
            const previousKeys = parseKeysMarker(existingSummary ? existingSummary.body : "");
            const currentKeys = new Set(issueEntries.map((entry) => entry.key));
            const newKeys = issueEntries
              .filter((entry) => !previousKeys.has(entry.key))
              .map((entry) => entry.key);
            const resolvedKeys = Array.from(previousKeys).filter((key) => !currentKeys.has(key));
            const unchangedCount = currentKeys.size - newKeys.length;
            const newKeySet = new Set(newKeys);

            const severityCounts = new Map();
            for (const entry of issueEntries) {
              const current = severityCounts.get(entry.severity) || 0;
              severityCounts.set(entry.severity, current + 1);
            }
            const severityBreakdown = Array.from(severityCounts.entries())
              .sort((a, b) => (severityOrder[a[0]] ?? 99) - (severityOrder[b[0]] ?? 99))
              .map(([severity, count]) => `${severity}: ${count}`)
              .join(" | ");

            const criticalNow = issueEntries.filter((entry) => criticalSet.has(entry.severity));
            const criticalNew = issueEntries.filter(
              (entry) => newKeySet.has(entry.key) && criticalSet.has(entry.severity)
            );
            const compactList = issueEntries.slice(0, limits.maxSummaryItems);
            const hiddenCount = Math.max(0, issueEntries.length - compactList.length);
            const keysMarker = `${keysMarkerPrefix}${issueEntries.map((entry) => entry.key).join(",")} -->`;

            const formatSummaryBody = () => {
              const topLine = "### Ai review";
              const statusLine = `**Decision**: ${decision} | **Risk score**: ${riskScore}`;
              const countLine = issueEntries.length
                ? `**Issues**: ${issueEntries.length} (${severityBreakdown})`
                : "**Issues**: 0";
              const deltaLine =
                `**Delta vs previous run**: +${newKeys.length} new | -${resolvedKeys.length} resolved | ${unchangedCount} unchanged`;
              const summaryText = summary || "No summary provided.";

              const criticalNowSection = criticalNow.length
                ? [
                    "#### Critical now (top 5)",
                    ...criticalNow.slice(0, 5).map((entry) => formatIssueLine(entry, true)),
                  ].join("\n")
                : "#### Critical now\nNo critical issues detected.";

              const criticalNewSection = criticalNew.length
                ? [
                    "#### New critical since last run",
                    ...criticalNew.slice(0, 5).map((entry) => formatIssueLine(entry, false)),
                  ].join("\n")
                : "#### New critical since last run\nNone.";

              const compactSection = issueEntries.length
                ? [
                    "<details>",
                    `<summary>All issues (compact, showing ${compactList.length}/${issueEntries.length})</summary>`,
                    "",
                    ...compactList.map((entry) => formatIssueLine(entry, false)),
                    hiddenCount > 0 ? `- ... and ${hiddenCount} more.` : "",
                    "</details>",
                  ]
                    .filter(Boolean)
                    .join("\n")
                : "";

              return [
                summaryMarker,
                topLine,
                "",
                statusLine,
                countLine,
                deltaLine,
                "",
                summaryText,
                "",
                criticalNowSection,
                "",
                criticalNewSection,
                "",
                compactSection,
                keysMarker,
              ]
                .join("\n")
                .replace(/\n{3,}/g, "\n\n");
            };

            const formatIssueBody = (entry, marker) => {
              const issue = entry.issue;
              const title = issue.title || "Issue";
              const location = issueLocation(issue);
              const message = truncate(issue.message, limits.maxMessageChars) || "No details provided.";
              const suggestion = truncate(issue.suggestion, limits.maxSuggestionChars);
              const confidence = confidenceText(issue);

              let body =
                `${marker}\n` +
                `### Ai review focus item\n\n` +
                `**[${entry.severity}]** ${title}\n\n` +
                `\`${location}\`\n\n` +
                `${message}\n\n` +
                `confidence: ${confidence}`;

              if (suggestion) {
                body += `\n\nSuggested fix: ${suggestion}`;
              }

              return body;
            };

            const summaryBody = formatSummaryBody();
            if (existingSummary) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existingSummary.id,
                body: summaryBody,
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: summaryBody,
              });
            }

            const desiredByKey = new Map();
            for (const entry of issueEntries.slice(0, limits.maxIssueComments)) {
              const key = entry.key;
              const marker = `${issueMarkerPrefix}${key} -->`;
              desiredByKey.set(key, formatIssueBody(entry, marker));
            }

            const existingIssueComments = existingComments.filter((c) =>
              (c.body || "").includes(issueMarkerPrefix)
            );
            const seenKeys = new Set();

            for (const comment of existingIssueComments) {
              const body = comment.body || "";
              const match = body.match(/<!-- ai-review:item:([a-f0-9]+) -->/);
              if (!match) {
                continue;
              }
              const key = match[1];
              seenKeys.add(key);
              if (!desiredByKey.has(key)) {
                await github.rest.issues.deleteComment({
                  owner,
                  repo,
                  comment_id: comment.id,
                });
                continue;
              }

              const newBody = desiredByKey.get(key);
              if (newBody && newBody !== body) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: comment.id,
                  body: newBody,
                });
              }
            }

            for (const [key, body] of desiredByKey) {
              if (seenKeys.has(key)) {
                continue;
              }
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body,
              });
            }

            core.info(
              `Published Ai review: total issues=${issueEntries.length}, detailed issue comments=${desiredByKey.size}.`
            );

      - name: Upload review artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ai-review-result
          path: result.json
          if-no-files-found: ignore
